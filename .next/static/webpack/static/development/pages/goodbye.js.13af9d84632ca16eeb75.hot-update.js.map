{"version":3,"file":"static/webpack/static/development/pages/goodbye.js.13af9d84632ca16eeb75.hot-update.js","sources":["webpack:///./utils/fx.2.js"],"sourcesContent":["import * as THREE from 'three';\nconst colors = [0x0000ff, 0x00ff00, 0xff0000, 0xf0f000, 0x00f0f0];\nconst vertexShader = require('./shaders/vertex_shader');\nconst fragmentShader = require('./shaders/fragment_shader');\n\nexport default (_this, window, document) => {\n    return () => {\n        // SETTING UP SCENE AND PERSPECTIVE MATRIX\n        const self = _this\n        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 1000)\n        const scene = new THREE.Scene()\n\n        // SETTING UP GEOMETRY AND MATERIAL\n        const icosaedronGeometry1 = new THREE.IcosahedronGeometry(300, 0)\n        const icosaedronGeometry2 = new THREE.IcosahedronGeometry(100, 1)\n        const lineSegmentsGeometry1 = new THREE.EdgesGeometry(icosaedronGeometry1);\n        const lineSegmentsGeometry2 = new THREE.EdgesGeometry(icosaedronGeometry2);\n\n        const lineSegmentsMaterial1 = new THREE.ShaderMaterial({\n            uniforms: {\n\n                time: {\n                    value: 1.0\n                },\n                resolution: {\n                    value: new THREE.Vector2()\n                },\n                r: {\n                    value: 255.0\n                },\n                g: {\n                    value: 255.0\n                },\n                b: {\n                    value: 255.0\n                }\n\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader\n        });\n        const lineSegmentsMaterial2 = new THREE.ShaderMaterial({\n            uniforms: {\n\n                time: {\n                    value: 1.0\n                },\n                resolution: {\n                    value: new THREE.Vector2()\n                },\n                r: {\n                    value: 255.0\n                },\n                g: {\n                    value: 255.0\n                },\n                b: {\n                    value: 255.0\n                }\n\n            },\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader\n        });\n\n        var vertexDisplacement = new Float32Array(lineSegmentsGeometry1.attributes.position.count);\n        for (let index = 0; index < vertexDisplacement.length; index++) {\n            vertexDisplacement[index] = 0;\n        }\n        lineSegmentsGeometry1.addAttribute('vertexDisplacement', new THREE.BufferAttribute(vertexDisplacement, 1));\n\n        const mesh1 = new THREE.LineSegments(lineSegmentsGeometry1, lineSegmentsMaterial1)\n        const mesh2 = new THREE.LineSegments(lineSegmentsGeometry2, lineSegmentsMaterial2)\n\n        //SETTING UP THE RENDERER\n        const renderer = new THREE.WebGLRenderer()\n\n        //SETTING UP CAMERA POSIION\n        camera.position.z = 600\n\n        //ADDING ELEMENTS TO THE SCENE\n        scene.add(mesh1)\n        scene.add(mesh2)\n\n        // SETTING UP PIXEL RATIO AND CANVAS SIZE\n        renderer.setPixelRatio(window.devicePixelRatio)\n        renderer.setSize(window.innerWidth, window.innerHeight)\n\n        //APPENDING CANAS TO THE DOM\n        document.getElementById('webgl-wrapper').appendChild(renderer.domElement)\n\n        //ADDING WINDOWS RESIZE EVENT\n        window.addEventListener('resize', _this.onWindowResize.bind(_this), false)\n\n        //ATTACHING ELEMENTS TO THE STATE SCOPE AND RUNING FIRST ANIMATION FRAME\n        _this.setState({\n            camera,\n            scene,\n            renderer,\n            mesh1,\n            mesh2\n        }, animate)\n\n        var fixIco = false;\n\n        setInterval(() => {\n            fixIco = !fixIco;\n        }, 4000);\n\n        function animate(t) {\n            let deltaColor = t * 0.0025\n            let delta1 = t * 0.00025\n            let delta2 = t * 0.0007875\n\n            requestAnimationFrame(animate);\n\n            self.state.mesh1.quaternion.setFromEuler(new THREE.Euler(delta1, delta1 * 2, 0));\n            self.state.mesh2.material.uniforms.r.value = Math.sin(deltaColor);\n            self.state.mesh2.material.uniforms.g.value = Math.cos(deltaColor);\n            self.state.mesh2.material.uniforms.b.value = Math.tan(deltaColor);\n\n            let repetitive = Math.floor(t / 1000) % 5;\n            let noise = repetitive === 0;\n\n            if (noise) {\n                for (let index = 0; index < vertexDisplacement.length; index++) {\n                    vertexDisplacement[index] = Math.random() * 100;\n                }\n                self.state.mesh1.geometry.attributes.vertexDisplacement.needsUpdate = true;\n            } else {\n                if (fixIco) {\n                    for (let index = 0; index < vertexDisplacement.length; index++) {\n                        vertexDisplacement[index] = 0;\n                    }\n                }\n                self.state.mesh1.geometry.attributes.vertexDisplacement.needsUpdate = true;\n            }\n\n            self.state.mesh2.quaternion.setFromEuler(new THREE.Euler(delta2, delta2 * 2, 0));\n            self.state.renderer.render(self.state.scene, self.state.camera);\n        }\n    }\n}"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AADA;AAGA;AACA;AADA;AAGA;AACA;AADA;AAGA;AACA;AADA;AAGA;AACA;AADA;AAdA;AAmBA;AACA;AArBA;AAuBA;AACA;AAEA;AACA;AADA;AAGA;AACA;AADA;AAGA;AACA;AADA;AAGA;AACA;AADA;AAGA;AACA;AADA;AAdA;AAmBA;AACA;AArBA;AAwBA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AACA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}